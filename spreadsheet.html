<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Stats Spreadsheet</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            color: #FF6600;
            margin-bottom: 10px;
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .controls button {
            padding: 8px 16px;
            background: #FF6600;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .controls button:hover {
            background: #e55a00;
        }
        .controls button.secondary {
            background: #444;
        }
        .controls button.secondary:hover {
            background: #555;
        }
        .search-box {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a3e;
            color: #eee;
            font-size: 14px;
            width: 200px;
        }
        .table-container {
            overflow-x: auto;
            border: 1px solid #333;
            border-radius: 4px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        table {
            border-collapse: collapse;
            font-size: 12px;
            white-space: nowrap;
        }
        th, td {
            border: 1px solid #333;
            padding: 6px 8px;
            text-align: center;
            min-width: 60px;
        }
        thead {
            position: sticky;
            top: 0;
            z-index: 20;
        }
        th {
            background: #2a2a3e;
            cursor: pointer;
            user-select: none;
        }
        th:hover {
            background: #3a3a4e;
        }
        th.sorted-asc::after {
            content: ' ▲';
            font-size: 10px;
        }
        th.sorted-desc::after {
            content: ' ▼';
            font-size: 10px;
        }
        .category-header {
            background: #FF6600 !important;
            color: white;
            font-weight: bold;
        }
        .sub-header {
            background: #2a2a3e !important;
        }
        td {
            background: #1e1e2e;
        }
        td.editable {
            background: #252538;
            cursor: text;
        }
        td.editable:hover {
            background: #303048;
        }
        td.editable:focus {
            outline: 2px solid #FF6600;
            background: #353550;
        }
        td.computed {
            background: #1a2a1a;
            color: #8f8;
            font-weight: bold;
        }
        td.position-rating {
            background: #1a1a2a;
            color: #88f;
            font-weight: bold;
        }
        td.overall {
            background: #2a1a1a;
            color: #f88;
            font-weight: bold;
        }
        td.name-cell {
            position: sticky;
            left: 0;
            background: #2a2a3e;
            z-index: 5;
            font-weight: bold;
            text-align: left;
        }
        td.modified {
            background: #4a3a1a !important;
        }
        td.default-value {
            color: #666;
            font-style: italic;
        }
        tr:hover td {
            filter: brightness(1.1);
        }
        .filter-input {
            width: 100%;
            padding: 2px 4px;
            font-size: 10px;
            border: 1px solid #444;
            background: #1a1a2e;
            color: #eee;
            margin-top: 4px;
            border-radius: 2px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: #2a2a3e;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
        }
        .modal-content h2 {
            margin-top: 0;
            color: #FF6600;
        }
        .modal-content input[type="password"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 16px;
        }
        .modal-content textarea {
            width: 100%;
            height: 300px;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            font-size: 12px;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            font-size: 12px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        .changes-indicator {
            color: #f88;
            font-weight: bold;
        }
        a {
            color: #FF6600;
        }
    </style>
</head>
<body>
    <h1>Player Stats Spreadsheet</h1>
    <p><a href="team.html">← Back to Team Builder</a></p>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #252538;"></div>
            <span>Editable</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #1a2a1a;"></div>
            <span>Computed (Category)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #1a1a2a;"></div>
            <span>Position Rating</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2a1a1a;"></div>
            <span>Overall</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4a3a1a;"></div>
            <span>Modified</span>
        </div>
    </div>

    <div class="controls">
        <input type="text" class="search-box" id="searchBox" placeholder="Search players...">
        <button onclick="resetFilters()">Reset Filters</button>
        <button onclick="resetChanges()" class="secondary">Reset Changes</button>
        <button onclick="showExportModal()">Export players.js</button>
        <span class="changes-indicator" id="changesIndicator"></span>
    </div>

    <div class="table-container">
        <table id="statsTable">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h2>Export players.js</h2>
            <p>Copy the full players.js content below and paste to replace the file:</p>
            <textarea id="exportContent" readonly></textarea>
            <div class="modal-buttons">
                <button onclick="copyExport()">Copy to Clipboard</button>
                <button class="secondary" onclick="closeModal('exportModal')">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            players,
            DEFAULT_STAT,
            computeShooting,
            computeInsideScoring,
            computeAthleticism,
            computePlaymaking,
            computeDefense,
            computeRebounding,
            computePGRating,
            computeSGRating,
            computeSFRating,
            computePFRating,
            computeCRating,
            computeOverallRating,
            computePosition
        } from './players.js';

        // Track modifications
        const modifications = new Map();

        // Column definitions - ordered to match Excel format exactly
        // Categories that can be collapsed (collapsed by default)
        const collapsibleCategories = new Set([
            'Shooting (S)', 'Inside Scoring (IS)', 'Athleticism (A)',
            'Playmaking (P)', 'Defense (D)', 'Rebounding (R)'
        ]);
        const expandedCategories = new Set(); // Start with all collapsed

        const statColumns = [
            // Overall Rating & Position (right after player name)
            { key: '_overall', label: 'Overall Rating', category: 'Overall', overall: true, formula: computeOverallRating },
            { key: '_position', label: 'Position', category: 'Overall', overall: true, formula: computePosition },

            // Shooting (S)
            { key: '_shooting', label: 'Overall (S)', category: 'Shooting (S)', computed: true, formula: computeShooting, isGroupHeader: true },
            { key: 'shotClose', label: 'Shot Close', category: 'Shooting (S)', editable: true, collapsible: true },
            { key: 'shotMid', label: 'Shot Mid', category: 'Shooting (S)', editable: true, collapsible: true },
            { key: 'shot3pt', label: 'Shot 3PT', category: 'Shooting (S)', editable: true, collapsible: true },
            { key: 'shotIQ', label: 'Shot IQ', category: 'Shooting (S)', editable: true, collapsible: true },
            { key: 'freeThrow', label: 'Free Throw', category: 'Shooting (S)', editable: true, collapsible: true },
            { key: 'offensiveConsistency', label: 'Offensive Consistency', category: 'Shooting (S)', editable: true, collapsible: true },

            // Inside Scoring (IS)
            { key: '_insideScoring', label: 'Overall (IS)', category: 'Inside Scoring (IS)', computed: true, formula: computeInsideScoring, isGroupHeader: true },
            { key: 'drivingLayup', label: 'Driving Layup', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'standingDunk', label: 'Standing Dunk', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'drivingDunk', label: 'Driving Dunk', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'drawFoul', label: 'Draw Foul', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'postMoves', label: 'Post Moves', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'postHook', label: 'Post Hook', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'postFade', label: 'Post Fade', category: 'Inside Scoring (IS)', editable: true, collapsible: true },
            { key: 'hands', label: 'Hands', category: 'Inside Scoring (IS)', editable: true, collapsible: true },

            // Athleticism (A)
            { key: '_athleticism', label: 'Overall (A)', category: 'Athleticism (A)', computed: true, formula: computeAthleticism, isGroupHeader: true },
            { key: 'speed', label: 'Speed', category: 'Athleticism (A)', editable: true, collapsible: true },
            { key: 'acceleration', label: 'Acceleration', category: 'Athleticism (A)', editable: true, collapsible: true },
            { key: 'vertical', label: 'Vertical', category: 'Athleticism (A)', editable: true, collapsible: true },
            { key: 'strength', label: 'Strength', category: 'Athleticism (A)', editable: true, collapsible: true },
            { key: 'stamina', label: 'Stamina', category: 'Athleticism (A)', editable: true, collapsible: true },
            { key: 'hustle', label: 'Hustle', category: 'Athleticism (A)', editable: true, collapsible: true },

            // Playmaking (P)
            { key: '_playmaking', label: 'Overall (P)', category: 'Playmaking (P)', computed: true, formula: computePlaymaking, isGroupHeader: true },
            { key: 'speedWithBall', label: 'Speed With Ball', category: 'Playmaking (P)', editable: true, collapsible: true },
            { key: 'ballHandle', label: 'Ball Handle', category: 'Playmaking (P)', editable: true, collapsible: true },
            { key: 'passingAccuracy', label: 'Passing Accuracy', category: 'Playmaking (P)', editable: true, collapsible: true },
            { key: 'passingVision', label: 'Passing Vision', category: 'Playmaking (P)', editable: true, collapsible: true },
            { key: 'passingIQ', label: 'Passing IQ', category: 'Playmaking (P)', editable: true, collapsible: true },

            // Defense (D)
            { key: '_defense', label: 'Overall (D)', category: 'Defense (D)', computed: true, formula: computeDefense, isGroupHeader: true },
            { key: 'interiorDefense', label: 'Interior Defense', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'perimeterDefense', label: 'Perimeter Defense', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'helpDefenseIQ', label: 'Help Defense IQ', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'lateralQuickness', label: 'Lateral Quickness', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'passPerception', label: 'Pass Perception', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'steal', label: 'Steal', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'block', label: 'Block', category: 'Defense (D)', editable: true, collapsible: true },
            { key: 'defensiveConsistency', label: 'Defensive Consistency', category: 'Defense (D)', editable: true, collapsible: true },

            // Rebounding (R)
            { key: '_rebounding', label: 'Overall (R)', category: 'Rebounding (R)', computed: true, formula: computeRebounding, isGroupHeader: true },
            { key: 'offensiveRebounding', label: 'Offensive Rebounding', category: 'Rebounding (R)', editable: true, collapsible: true },
            { key: 'defensiveRebounding', label: 'Defensive Rebounding', category: 'Rebounding (R)', editable: true, collapsible: true },

            // Mental
            { key: 'intangibles', label: 'Intangibles', category: 'Mental', editable: true },
            { key: 'potential', label: 'Potential', category: 'Mental', editable: true },

            // Position Ratings (at the END, matching Excel)
            { key: '_pgRating', label: 'PG Rating', category: 'Position Ratings', posRating: true, formula: computePGRating },
            { key: '_sgRating', label: 'SG Rating', category: 'Position Ratings', posRating: true, formula: computeSGRating },
            { key: '_sfRating', label: 'SF Rating', category: 'Position Ratings', posRating: true, formula: computeSFRating },
            { key: '_pfRating', label: 'PF Rating', category: 'Position Ratings', posRating: true, formula: computePFRating },
            { key: '_cRating', label: 'C Rating', category: 'Position Ratings', posRating: true, formula: computeCRating }
        ];

        // Get visible columns based on collapsed state
        function getVisibleColumns() {
            return statColumns.filter(col => {
                if (!col.collapsible) return true;
                return expandedCategories.has(col.category);
            });
        }

        // Toggle category expansion
        window.toggleCategory = function(category) {
            if (expandedCategories.has(category)) {
                expandedCategories.delete(category);
            } else {
                expandedCategories.add(category);
            }
            buildHeaders();
            buildBody();
        };

        // Get unique categories
        const categories = [...new Set(statColumns.map(c => c.category))];

        // Current sort state
        let sortColumn = null;
        let sortDirection = 'asc';
        let filters = {};

        // Deep clone players for modifications
        let playerData = JSON.parse(JSON.stringify(players));

        // Get stats with modifications applied
        function getPlayerStats(playerIndex) {
            const player = playerData[playerIndex];
            const stats = { ...player.stats };

            // Apply any modifications
            const playerMods = modifications.get(playerIndex);
            if (playerMods) {
                for (const [key, value] of playerMods) {
                    stats[key] = value;
                }
            }

            return stats;
        }

        // Build table headers
        function buildHeaders() {
            const thead = document.getElementById('tableHead');
            const visibleColumns = getVisibleColumns();

            // Category row
            let categoryRow = '<tr>';
            categoryRow += '<th class="category-header" rowspan="2">Player</th>';

            let currentCategory = null;
            let categorySpan = 0;

            visibleColumns.forEach((col, i) => {
                if (col.category !== currentCategory) {
                    if (currentCategory !== null) {
                        const isCollapsible = collapsibleCategories.has(currentCategory);
                        const isExpanded = expandedCategories.has(currentCategory);
                        const toggle = isCollapsible ? (isExpanded ? ' ▼' : ' ▶') : '';
                        const clickHandler = isCollapsible ? `onclick="toggleCategory('${currentCategory}')"` : '';
                        const cursorStyle = isCollapsible ? 'cursor: pointer;' : '';
                        categoryRow += `<th class="category-header" colspan="${categorySpan}" ${clickHandler} style="${cursorStyle}" title="${isCollapsible ? 'Click to expand/collapse' : ''}">${currentCategory}${toggle}</th>`;
                    }
                    currentCategory = col.category;
                    categorySpan = 1;
                } else {
                    categorySpan++;
                }

                if (i === visibleColumns.length - 1) {
                    const isCollapsible = collapsibleCategories.has(currentCategory);
                    const isExpanded = expandedCategories.has(currentCategory);
                    const toggle = isCollapsible ? (isExpanded ? ' ▼' : ' ▶') : '';
                    const clickHandler = isCollapsible ? `onclick="toggleCategory('${currentCategory}')"` : '';
                    const cursorStyle = isCollapsible ? 'cursor: pointer;' : '';
                    categoryRow += `<th class="category-header" colspan="${categorySpan}" ${clickHandler} style="${cursorStyle}" title="${isCollapsible ? 'Click to expand/collapse' : ''}">${currentCategory}${toggle}</th>`;
                }
            });
            categoryRow += '</tr>';

            // Column headers row
            let headerRow = '<tr>';
            visibleColumns.forEach((col, i) => {
                const originalIndex = statColumns.indexOf(col);
                headerRow += `<th class="sub-header" data-column="${originalIndex}" onclick="window.sortByColumn(${originalIndex})">${col.label}</th>`;
            });
            headerRow += '</tr>';

            thead.innerHTML = categoryRow + headerRow;
        }

        // Build table body
        function buildBody() {
            const tbody = document.getElementById('tableBody');
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();

            let rows = playerData.map((player, index) => ({ player, index }));

            // Filter by search
            if (searchTerm) {
                rows = rows.filter(r => r.player.name.toLowerCase().includes(searchTerm));
            }

            // Sort
            if (sortColumn !== null) {
                rows.sort((a, b) => {
                    const col = statColumns[sortColumn];
                    let valA, valB;

                    if (col.formula) {
                        valA = col.formula(getPlayerStats(a.index));
                        valB = col.formula(getPlayerStats(b.index));
                    } else {
                        valA = getPlayerStats(a.index)[col.key] || 0;
                        valB = getPlayerStats(b.index)[col.key] || 0;
                    }

                    if (typeof valA === 'string') {
                        return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                });
            }

            let html = '';
            rows.forEach(({ player, index }) => {
                const stats = getPlayerStats(index);
                const playerMods = modifications.get(index) || new Map();

                html += '<tr>';
                html += `<td class="name-cell">${player.name}</td>`;

                getVisibleColumns().forEach(col => {
                    let value;
                    let cellClass = '';

                    if (col.formula) {
                        value = col.formula(stats);
                        if (col.computed) cellClass = 'computed';
                        else if (col.posRating) cellClass = 'position-rating';
                        else if (col.overall) cellClass = 'overall';
                    } else {
                        value = stats[col.key];
                        if (col.editable) {
                            cellClass = 'editable';
                            if (playerMods.has(col.key)) {
                                cellClass += ' modified';
                            } else if (value === DEFAULT_STAT) {
                                cellClass += ' default-value';
                            }
                        }
                    }

                    const displayValue = typeof value === 'number' ?
                        (Number.isInteger(value) ? value : value.toFixed(1)) : value;

                    if (col.editable) {
                        html += `<td class="${cellClass}" contenteditable="true"
                            data-player="${index}" data-stat="${col.key}"
                            onblur="window.handleCellEdit(this)"
                            onkeydown="window.handleCellKeydown(event, this)">${displayValue}</td>`;
                    } else {
                        html += `<td class="${cellClass}">${displayValue}</td>`;
                    }
                });

                html += '</tr>';
            });

            tbody.innerHTML = html;
        }

        // Sort by column
        window.sortByColumn = function(columnIndex) {
            // Clear previous sort indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = columnIndex;
                sortDirection = 'desc'; // Default to descending for stats
            }

            // Add sort indicator
            const th = document.querySelector(`th[data-column="${columnIndex}"]`);
            if (th) {
                th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
            }

            buildBody();
        };

        // Handle cell edit
        window.handleCellEdit = function(cell) {
            const playerIndex = parseInt(cell.dataset.player);
            const statKey = cell.dataset.stat;
            const newValue = parseFloat(cell.textContent);

            if (isNaN(newValue)) {
                // Revert to original value
                const stats = getPlayerStats(playerIndex);
                cell.textContent = stats[statKey];
                return;
            }

            // Store modification
            if (!modifications.has(playerIndex)) {
                modifications.set(playerIndex, new Map());
            }

            const originalValue = playerData[playerIndex].stats[statKey];
            if (newValue !== originalValue) {
                modifications.get(playerIndex).set(statKey, newValue);
                cell.classList.add('modified');
            } else {
                modifications.get(playerIndex).delete(statKey);
                cell.classList.remove('modified');
                if (originalValue === DEFAULT_STAT) {
                    cell.classList.add('default-value');
                }
            }

            updateChangesIndicator();

            // Rebuild to update computed columns
            buildBody();
        };

        // Handle keydown in cells
        window.handleCellKeydown = function(event, cell) {
            if (event.key === 'Enter') {
                event.preventDefault();
                cell.blur();
            } else if (event.key === 'Tab') {
                // Allow tab to move between cells
            } else if (event.key === 'Escape') {
                const playerIndex = parseInt(cell.dataset.player);
                const statKey = cell.dataset.stat;
                const stats = getPlayerStats(playerIndex);
                cell.textContent = stats[statKey];
                cell.blur();
            }
        };

        // Update changes indicator
        function updateChangesIndicator() {
            let totalChanges = 0;
            modifications.forEach(playerMods => {
                totalChanges += playerMods.size;
            });

            const indicator = document.getElementById('changesIndicator');
            if (totalChanges > 0) {
                indicator.textContent = `${totalChanges} unsaved change${totalChanges > 1 ? 's' : ''}`;
            } else {
                indicator.textContent = '';
            }
        }

        // Reset filters
        window.resetFilters = function() {
            document.getElementById('searchBox').value = '';
            sortColumn = null;
            sortDirection = 'asc';
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });
            buildBody();
        };

        // Reset changes
        window.resetChanges = function() {
            if (modifications.size > 0 && !confirm('Are you sure you want to reset all changes?')) {
                return;
            }
            modifications.clear();
            updateChangesIndicator();
            buildBody();
        };

        // Show export modal
        window.showExportModal = function() {
            generateExport();
        };

        // Close modal
        window.closeModal = function(modalId) {
            document.getElementById(modalId).classList.remove('active');
        };

        // Generate export content - full players.js file
        function generateExport() {
            // Apply modifications to player data
            const exportData = JSON.parse(JSON.stringify(playerData));

            modifications.forEach((playerMods, playerIndex) => {
                playerMods.forEach((value, key) => {
                    exportData[playerIndex].stats[key] = value;
                });
            });

            // Generate the full players.js file
            let code = `// players.js
// Default stat value - stats with this exact value were not from CSV
export const DEFAULT_STAT = 70.7070707;

// Helper to check if a stat is a default value
export const isDefaultStat = (value) => value === DEFAULT_STAT;

// Category formulas from spreadsheet:

// Shooting: (0.8 + offensiveConsistency/500) * 0.5*top1 + 0.35*avg(2nd,3rd) + 0.1*shotIQ + 0.05*freeThrow
export const computeShooting = (stats) => {
    const shots = [stats.shotClose, stats.shotMid, stats.shot3pt].sort((a, b) => b - a);
    const consistencyMult = 0.8 + stats.offensiveConsistency / 500;
    return Math.round(
        consistencyMult * 0.5 * shots[0] +
        0.35 * (shots[1] + shots[2]) / 2 +
        0.1 * stats.shotIQ +
        0.05 * stats.freeThrow
    );
};

// Inside Scoring: 0.65*top1 + 0.2*avg(2nd,3rd) + 0.05*avg(4th,5th,6th) + 0.05*hands + 0.05*drawFoul
export const computeInsideScoring = (stats) => {
    const moves = [
        stats.drivingLayup, stats.standingDunk, stats.drivingDunk,
        stats.postMoves, stats.postHook, stats.postFade
    ].sort((a, b) => b - a);
    return Math.round(
        0.65 * moves[0] +
        0.2 * (moves[1] + moves[2]) / 2 +
        0.05 * (moves[3] + moves[4] + moves[5]) / 3 +
        0.05 * stats.hands +
        0.05 * stats.drawFoul
    );
};

// Athleticism: 0.21*speed + 0.21*accel + 0.21*vertical + 0.21*strength + 0.08*stamina + 0.08*hustle
export const computeAthleticism = (stats) => {
    return Math.round(
        0.21 * stats.speed +
        0.21 * stats.acceleration +
        0.21 * stats.vertical +
        0.21 * stats.strength +
        0.08 * stats.stamina +
        0.08 * stats.hustle
    );
};

// Playmaking: 0.23*speedWithBall + 0.23*ballHandle + 0.23*passAccuracy + 0.23*passVision + 0.08*passIQ
export const computePlaymaking = (stats) => {
    return Math.round(
        0.23 * stats.speedWithBall +
        0.23 * stats.ballHandle +
        0.23 * stats.passingAccuracy +
        0.23 * stats.passingVision +
        0.08 * stats.passingIQ
    );
};

// Defense: (0.8 + defConsistency/500) * weighted formula
export const computeDefense = (stats) => {
    const consistencyMult = 0.8 + stats.defensiveConsistency / 500;
    return Math.round(
        consistencyMult * (
            0.37 * Math.max(stats.interiorDefense, stats.perimeterDefense) +
            0.15 * Math.min(stats.interiorDefense, stats.perimeterDefense) +
            0.1 * Math.max(stats.steal, stats.block) +
            0.08 * Math.min(stats.steal, stats.block) +
            0.1 * stats.helpDefenseIQ +
            0.1 * stats.lateralQuickness +
            0.1 * stats.passPerception
        )
    );
};

// Rebounding: average(offReb, defReb)
export const computeRebounding = (stats) => {
    return Math.round((stats.offensiveRebounding + stats.defensiveRebounding) / 2);
};

// Position rating formulas (include intangibles/100 + potential/200)
// PG: 0.28*S + 0.09*IS + 0.12*A + 0.38*P + 0.08*D + 0.05*R + intangibles/100 + potential/200
export const computePGRating = (stats) => {
    const s = computeShooting(stats);
    const is = computeInsideScoring(stats);
    const a = computeAthleticism(stats);
    const p = computePlaymaking(stats);
    const d = computeDefense(stats);
    const r = computeRebounding(stats);
    const base = 0.28 * s + 0.09 * is + 0.12 * a + 0.38 * p + 0.08 * d + 0.05 * r;
    return Math.round((base + stats.intangibles / 100 + stats.potential / 200) * 10) / 10;
};

// SG: 0.34*S + 0.12*IS + 0.19*A + 0.16*P + 0.12*D + 0.07*R + intangibles/100 + potential/200
export const computeSGRating = (stats) => {
    const s = computeShooting(stats);
    const is = computeInsideScoring(stats);
    const a = computeAthleticism(stats);
    const p = computePlaymaking(stats);
    const d = computeDefense(stats);
    const r = computeRebounding(stats);
    const base = 0.34 * s + 0.12 * is + 0.19 * a + 0.16 * p + 0.12 * d + 0.07 * r;
    return Math.round((base + stats.intangibles / 100 + stats.potential / 200) * 10) / 10;
};

// SF: 0.21*S + 0.17*IS + 0.20*A + 0.09*P + 0.20*D + 0.13*R + intangibles/100 + potential/200
export const computeSFRating = (stats) => {
    const s = computeShooting(stats);
    const is = computeInsideScoring(stats);
    const a = computeAthleticism(stats);
    const p = computePlaymaking(stats);
    const d = computeDefense(stats);
    const r = computeRebounding(stats);
    const base = 0.21 * s + 0.17 * is + 0.20 * a + 0.09 * p + 0.20 * d + 0.13 * r;
    return Math.round((base + stats.intangibles / 100 + stats.potential / 200) * 10) / 10;
};

// PF: 0.10*S + 0.21*IS + 0.24*A + 0.06*P + 0.20*D + 0.19*R + intangibles/100 + potential/200
export const computePFRating = (stats) => {
    const s = computeShooting(stats);
    const is = computeInsideScoring(stats);
    const a = computeAthleticism(stats);
    const p = computePlaymaking(stats);
    const d = computeDefense(stats);
    const r = computeRebounding(stats);
    const base = 0.10 * s + 0.21 * is + 0.24 * a + 0.06 * p + 0.20 * d + 0.19 * r;
    return Math.round((base + stats.intangibles / 100 + stats.potential / 200) * 10) / 10;
};

// C: 0.06*S + 0.24*IS + 0.20*A + 0.00*P + 0.25*D + 0.25*R + intangibles/100 + potential/200
export const computeCRating = (stats) => {
    const s = computeShooting(stats);
    const is = computeInsideScoring(stats);
    const a = computeAthleticism(stats);
    const p = computePlaymaking(stats);
    const d = computeDefense(stats);
    const r = computeRebounding(stats);
    const base = 0.06 * s + 0.24 * is + 0.20 * a + 0.00 * p + 0.25 * d + 0.25 * r;
    return Math.round((base + stats.intangibles / 100 + stats.potential / 200) * 10) / 10;
};

// Overall rating: max of all position ratings
export const computeOverallRating = (stats) => {
    return Math.round(Math.max(
        computePGRating(stats),
        computeSGRating(stats),
        computeSFRating(stats),
        computePFRating(stats),
        computeCRating(stats)
    ));
};

// Compute position string based on ratings (e.g., "PG/SG", "SF", "PF/C")
// Primary position is the max rating, co-positions are within 1 point of max
export const computePosition = (stats) => {
    const positions = [
        { pos: 'PG', rating: computePGRating(stats) },
        { pos: 'SG', rating: computeSGRating(stats) },
        { pos: 'SF', rating: computeSFRating(stats) },
        { pos: 'PF', rating: computePFRating(stats) },
        { pos: 'C', rating: computeCRating(stats) }
    ];

    // Sort by rating descending
    positions.sort((a, b) => b.rating - a.rating);
    const maxRating = positions[0].rating;

    // Get all positions within 1 point of max
    const validPositions = positions.filter(p => maxRating - p.rating <= 1);

    return validPositions.map(p => p.pos).join('/');
};

export const players = [
`;

            // Generate each player
            exportData.forEach((player, idx) => {
                code += `
    {
        old_number: ${player.old_number},
        number: ${player.number},
        name: "${player.name}",
        team: "${player.team}",
        position: "${player.position}",
        height: "${player.height}",
        weight: "${player.weight}",
        age: ${player.age},
        season: ${player.season},
        image: "${player.image}",
        description: ${JSON.stringify(player.description)},
        icons: ${JSON.stringify(player.icons)},
        shades_of: ${JSON.stringify(player.shades_of)},
        offense: ${player.offense},
        defense: ${player.defense},
        aggressive: ${player.aggressive},
        stats: {
            // Shooting
            shotClose: ${player.stats.shotClose},
            shotMid: ${player.stats.shotMid},
            shot3pt: ${player.stats.shot3pt},
            shotIQ: ${player.stats.shotIQ},
            freeThrow: ${player.stats.freeThrow},
            offensiveConsistency: ${player.stats.offensiveConsistency},
            // Inside Scoring
            drivingLayup: ${player.stats.drivingLayup},
            standingDunk: ${player.stats.standingDunk},
            drivingDunk: ${player.stats.drivingDunk},
            drawFoul: ${player.stats.drawFoul},
            postMoves: ${player.stats.postMoves},
            postHook: ${player.stats.postHook},
            postFade: ${player.stats.postFade},
            hands: ${player.stats.hands},
            // Athleticism
            speed: ${player.stats.speed},
            acceleration: ${player.stats.acceleration},
            vertical: ${player.stats.vertical},
            strength: ${player.stats.strength},
            stamina: ${player.stats.stamina},
            hustle: ${player.stats.hustle},
            // Playmaking
            speedWithBall: ${player.stats.speedWithBall},
            ballHandle: ${player.stats.ballHandle},
            passingAccuracy: ${player.stats.passingAccuracy},
            passingVision: ${player.stats.passingVision},
            passingIQ: ${player.stats.passingIQ},
            // Defense
            interiorDefense: ${player.stats.interiorDefense},
            perimeterDefense: ${player.stats.perimeterDefense},
            helpDefenseIQ: ${player.stats.helpDefenseIQ},
            lateralQuickness: ${player.stats.lateralQuickness},
            passPerception: ${player.stats.passPerception},
            steal: ${player.stats.steal},
            block: ${player.stats.block},
            defensiveConsistency: ${player.stats.defensiveConsistency},
            // Rebounding
            offensiveRebounding: ${player.stats.offensiveRebounding},
            defensiveRebounding: ${player.stats.defensiveRebounding},
            // Mental
            intangibles: ${player.stats.intangibles},
            potential: ${player.stats.potential}
        }
    }${idx < exportData.length - 1 ? ',' : ''}`;
            });

            code += `
];
`;

            document.getElementById('exportContent').value = code;
            document.getElementById('exportModal').classList.add('active');
        }

        // Copy export to clipboard
        window.copyExport = function() {
            const textarea = document.getElementById('exportContent');
            textarea.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        };

        // Search handler
        document.getElementById('searchBox').addEventListener('input', () => {
            buildBody();
        });

        
        // Initialize
        buildHeaders();
        buildBody();
    </script>
</body>
</html>
